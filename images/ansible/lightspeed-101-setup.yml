---
##
# lightspeed-101 lab controller configuration
##
- name: Configure localhost and instances
  hosts: localhost
  gather_facts: false

  vars:
    gcp_login: &gcp_login
      project: "{{ gcp_project }}"
      auth_kind: serviceaccount
      service_account_file: "{{ gcp_service_account_file }}"
    track_slug: lightspeed-101

  pre_tasks:
    - name: Include variable tasks
      vars:
        extra_vars:
          - name: track_slug
            env: track_slug
          - name: gcp_service_account_file
            env: GCP_SERVICE_ACCOUNT_FILE
          - name: gcp_service_account
            env: GCP_SERVICE_ACCOUNT
          - name: gcp_instances
          - name: gcp_project
            env: GCP_PROJECT
      ansible.builtin.include_tasks:
        file: "{{ playbook_dir }}/common/60_check_vars.yml"
        apply:
          tags:
            - always
      tags:
        - always

  tasks:
    # use '--tags never' if using ansible-playbook to install collections
    - name: Install collections - {{ inventory_hostname }}
      vars:
        controller_collections:
          - google.cloud
          - ansible.posix
          - community.crypto
          - containers.podman
          - redhat_cop.controller_configuration
          - awx.awx
      community.general.ansible_galaxy_install:
        dest: /usr/share/ansible/collections
        type: collection
        name: "{{ item }}"
      loop: "{{ controller_collections }}"
      register: __collection_install
      when: (controller_collections is defined) and (controller_collections | length > 0)
      tags:
        - never

    - name: Remove existing gcloud instances
      when: (gcp_instances is defined) and (gcp_instances | length > 0)
      tags:
        - remove-instances
      block:
        - name: Remove gcloud instances
          google.cloud.gcp_compute_instance:
            name: "{{ __remove_instances_job_async_item.name }}"
            state: absent
            zone: "{{ gcp_zone }}"
            labels: "{{ __create_instances_job_async_item.labels | default(omit) }}"
            tags: "{{ __create_instances_job_async_item.tags | default(omit) }}"
            <<: *gcp_login
          loop: "{{ gcp_instances }}"
          loop_control:
            loop_var: __remove_instances_job_async_item
            label: "{{ __remove_instances_job_async_item.name }}"
          async: 1000
          poll: 0
          register: __remove_instances_job_async
          changed_when: not __remove_instances_job_async.changed

        - name: "Remove existing gcloud instances | Wait for finish the instance deletion"
          ansible.builtin.async_status:
            jid: "{{ __remove_instances_job_async_result_item.ansible_job_id }}"
          retries: 60
          delay: 1
          loop: "{{ __remove_instances_job_async.results }}"
          loop_control:
            loop_var: __remove_instances_job_async_result_item
            label: "{{ __remove_instances_job_async_result_item.__remove_instances_job_async_item.name }}"
          until: __remove_instances_job_async_result.finished
          register: __remove_instances_job_async_result
          when: __remove_instances_job_async_result_item.ansible_job_id is defined

    - name: Create gcloud instances
      when: (gcp_instances is defined) and (gcp_instances | length > 0)
      tags:
        - create-instances
      block:
        - name: Create new gcloud instances
          google.cloud.gcp_compute_instance:
            name: "{{ __create_instances_job_async_item.name }}"
            machine_type: "{{ __create_instances_job_async_item.machine_type }}"
            labels: "{{ __create_instances_job_async_item.labels | default(omit) }}"
            tags: "{{ __create_instances_job_async_item.tags | default(omit) }}"
            state: present
            zone: "{{ gcp_zone }}"
            network_interfaces: "{{ __create_instances_job_async_item.network_interfaces }}"
            disks: "{{ __create_instances_job_async_item.disks }}"
            metadata: "{{ __create_instances_job_async_item.metadata }}"
            <<: *gcp_login
          loop: "{{ gcp_instances }}"
          loop_control:
            loop_var: __create_instances_job_async_item
            label: "{{ __create_instances_job_async_item.name }}"
          async: 1000
          poll: 0
          register: __create_instances_job_async
          changed_when: not __create_instances_job_async.changed

        - name: Create new gcloud instances | Async
          ansible.builtin.async_status:
            jid: "{{ __create_instances_job_async_result_item.ansible_job_id }}"
          retries: 60
          delay: 1
          loop: "{{ __create_instances_job_async.results }}"
          loop_control:
            loop_var: __create_instances_job_async_result_item
            label: "{{ __create_instances_job_async_result_item.__create_instances_job_async_item.name }}"
          until: __create_instances_job_async_result.finished
          register: __create_instances_job_async_result
          when: __create_instances_job_async_result_item.ansible_job_id is defined
      rescue:
        - name: Print error message
          ansible.builtin.fail:
            msg: |
              "Rescue - Unable to create gcloud instances.
              "{{ __create_instances_job_async_result }}"
          notify:
            - remove instances

    - name: Get gcp node instance info
      google.cloud.gcp_compute_instance_info: # noqa syntax-check
        filters:
          - labels.role = "{{ track_slug }}"
        zone: "{{ gcp_zone }}"
        <<: *gcp_login
      register: __mesh_node_instance_info
      tags:
        - create-instances

    - name: Wait for gcloud instances to start
      when:
        - (__mesh_node_instance_info.resources is defined) and (__mesh_node_instance_info.resources | length > 0)
        - (gcp_instances is defined) and (gcp_instances | length > 0)
      tags:
        - create-instances
      block:
        - name: Wait for gcloud instances - SSH
          ansible.builtin.wait_for:
            host: "{{ __instances_ssh_async_item.networkInterfaces[0].accessConfigs[0].natIP }}"
            port: 22
            delay: 1
            timeout: 180
          loop: "{{ __mesh_node_instance_info.resources }}"
          loop_control:
            loop_var: __instances_ssh_async_item
            label: "{{ __instances_ssh_async_item.name }}"
          async: 1000
          poll: 0
          register: __instances_ssh_async
          changed_when: not __instances_ssh_async.changed

        - name: "Wait for gcloud instances - SSH | Wait for SSH"
          ansible.builtin.async_status:
            jid: "{{ __instances_ssh_async_result_item.ansible_job_id }}"
          retries: 180
          delay: 1
          loop: "{{ __instances_ssh_async.results }}"
          loop_control:
            loop_var: __instances_ssh_async_result_item
            label: "{{ __instances_ssh_async_result_item.__instances_ssh_async_item.name }}"
          until: __instances_ssh_async_result.finished
          register: __instances_ssh_async_result
          when: __instances_ssh_async_result_item.ansible_job_id is defined
      rescue:
        - name: Print error message
          ansible.builtin.fail:
            msg: |
              "Rescue - Unable to connect to GCloud instances SSH.
              "{{ __instances_ssh_async_result }}"
          notify: remove instances

    - name: Add gcp controller hosts to inventory
      ansible.builtin.add_host:
        name: "{{ item.name }}"
        groups: "automationcontroller"
        ansible_host: "{{ item.networkInterfaces[0].accessConfigs[0].natIP }}"
      args: "{{ gcp_inventory_host_vars | default(omit) }}"
      loop: "{{ __mesh_node_instance_info.resources }}"
      loop_control:
        label: "{{ item.name }}"
      when:
        - item.labels["mesh-type"] == "controller"
        - (__mesh_node_instance_info.resources is defined) and (__mesh_node_instance_info.resources | length > 0)
      tags:
        - create-instances

    - name: Remove previous known_hosts keys - {{ inventory_hostname }}
      ansible.builtin.known_hosts:
        name: "{{ item.networkInterfaces[0].accessConfigs[0].natIP }}"
        state: absent
      loop: "{{ __mesh_node_instance_info.resources }}"
      loop_control:
        label: "{{ item.name }}"
      when: (__mesh_node_instance_info.resources is defined) and (__mesh_node_instance_info.resources | length > 0)
      tags:
        - create-instances
        - ssh-key

    - name: Add keys to known_hosts file - {{ inventory_hostname }}
      ansible.builtin.known_hosts:
        name: "{{ hostvars[item].ansible_host }}"
        state: present
        key: "{{ lookup('ansible.builtin.pipe', 'ssh-keyscan {{ hostvars[item].ansible_host }}') }}"
        hash_host: true
      loop: "{{ query('inventory_hostnames', 'all') }}"

    - name: Create installation SSH key
      when: (__mesh_node_instance_info.resources is defined) and (__mesh_node_instance_info.resources | length > 0)
      tags:
        - create-instances
      block:
        - name: Create temp dir for ssh keys
          ansible.builtin.tempfile:
            state: directory
            prefix: instruqt_ssh_
          register: _ssh_tempdir

        - name: Generate temp OpenSSH key pair for nodes
          community.crypto.openssh_keypair:
            path: "{{ _ssh_tempdir.path }}/instruqt_lab"
            force: true

# Common configuration tasks
- name: Configure common tasks on all hosts
  hosts: all
  become: true
  gather_facts: true
  tags:
    - common-tasks

  pre_tasks:
    - name: Include variable tasks
      ansible.builtin.include_tasks:
        file: "{{ playbook_dir }}/common/60_check_vars.yml"
        apply:
          tags:
            - always
      tags:
        - always
  tasks:
    - name: Include common user tasks
      ansible.builtin.include_tasks:
        file: "{{ playbook_dir }}/common/5_configure_users.yml"

    - name: Add instruqt_lab ssh key to authorized keys
      ansible.posix.authorized_key:
        user: "{{ item }}"
        state: present
        key: "{{ lookup('file', hostvars.localhost._ssh_tempdir.path + '/instruqt_lab.pub') }}"
        comment: "Instruqt lab key"
      loop:
        - "{{ student_username }}"
        - "{{ admin_username }}"
        - "{{ ansible_user_id }}" # root because of become: true

# Controller config
- name: Configure controller and containers
  hosts: automationcontroller
  become: true

  pre_tasks:
    - name: Include variable tasks
      vars:
        extra_vars:
          - name: lab_containers
      ansible.builtin.include_tasks:
        file: "{{ playbook_dir }}/common/60_check_vars.yml"
        apply:
          tags:
            - always
      tags:
        - always

  tasks:
    - name: Copy instruqt_lab ssh private key to controller
      ansible.builtin.copy:
        src: "{{ hostvars.localhost._ssh_tempdir.path }}/"
        dest: "~{{ item }}/.ssh/"
        owner: "{{ item }}"
        group: "{{ item }}"
        mode: "0600"
      loop:
        - "{{ admin_username }}"
        - "{{ ansible_user_id }}" # root because of become: true
        - "{{ student_username }}"
      when: (hostvars.localhost._ssh_tempdir.path is defined) and (hostvars.localhost._ssh_tempdir.path | length > 0)

    - name: Get gcp node instance info
      google.cloud.gcp_compute_instance_info: # noqa syntax-check
        filters:
          - labels.role = "{{ track_slug }}"
          - labels.mesh-type = controller
        zone: "{{ gcp_zone }}"
        <<: *gcp_login
      delegate_to: localhost
      become: false
      register: __controller_instance_info
      tags:
        - post-install

    - name: Set controller hostname fact for post install tasks
      ansible.builtin.set_fact:
        controller_hostname: "https://{{ __controller_instance_info.resources[0].networkInterfaces[0].accessConfigs[0].natIP }}"
      when: (__controller_instance_info is defined) and (__controller_instance_info | length > 0)
      tags:
        - post-install

    - name: Include common controller install tasks
      ansible.builtin.include_tasks:
        file: "{{ playbook_dir }}/common/50_install_controller.yml"

    # Post-install tasks here to install AWS packages for S3s
    - name: Include common controller post install tasks
      ansible.builtin.include_tasks:
        file: "{{ playbook_dir }}/common/70_controller_post_install.yml"
        apply:
          tags:
            - post-install
      tags:
        - post-install

    # #  TODO add to common post install tasks
    # - name: Copy ansible-navigator.yml template - {{ student_username }}
    #   ansible.builtin.template:
    #     src: "ansible-navigator.yml.j2"
    #     dest: "~{{ student_username }}/.ansible-navigator.yml"
    #     mode: "0644"
    #     owner: "{{ student_username }}"
    #     group: "{{ student_username }}"
    #   tags:
    #     - navigator

    # - name: Download navigator execution environment - {{ student_username }}
    #   # same var used in 50_install_controller.yml to pre-populate all mesh nodes with execution environments
    #   when: (lab.navigator_execution_environment is defined) and (lab.navigator_execution_environment | length > 0)
    #   tags:
    #     - navigator
    #   block:
    #     - name: Install podman collection - {{ inventory_hostname }}
    #       community.general.ansible_galaxy_install:
    #         type: collection
    #         name: containers.podman

    #     - name: Pull execution environment images
    #       become_user: "{{ student_username }}"
    #       containers.podman.podman_image:
    #         name: "{{ lab.navigator_execution_environment }}"
    #       register: __podman_pull_nav_ee
    #       until: __podman_pull_nav_ee is not failed
    #       retries: 60
    #       delay: 1

    - name: Include kiosk_mode role
      ansible.builtin.include_role:
        name: kiosk_mode
        apply:
          tags:
            - kiosk
      tags:
        - kiosk

    - name: Include vs_code role
      ansible.builtin.include_role:
        name: vs_code
        apply:
          tags:
            - code
      tags:
        - code

    - name: Include vnc_server role
      ansible.builtin.include_role:
        name: vnc_server
        apply:
          tags:
            - vnc
      tags:
        - vnc

    - name: Setup containers
      when: lab_containers is defined and lab_containers | length > 0
      tags:
        - create-containers
      block:
        - name: Start custom containers
          containers.podman.podman_container:
            name: "{{ __start_containers_async_item.name | default(omit) }}"
            annotation: "{{ __start_containers_async_item.annotation | default(omit) }}"
            label: "{{ __start_containers_async_item.label | default(omit) }}"
            image: "{{ __start_containers_async_item.image | default(omit) }}"
            memory: "{{ __start_containers_async_item.memory | default(omit) }}"
            privileged: "{{ __start_containers_async_item.privileged | default(false) }}"
            publish: "{{ __start_containers_async_item.publish | default(omit) }}"
            volume: "{{ __start_containers_async_item.volume | default(omit) }}"
            env_file: "{{ __start_containers_async_item.env_file | default(omit) }}"
            env_host: "{{ __start_containers_async_item.env_host | default(omit) }}"
            etc_hosts: "{{ __start_containers_async_item.etc_hosts | default(omit) }}"
            ip: "{{ __start_containers_async_item.ip | default(omit) }}"
            network: "{{ __start_containers_async_item.network | default(omit) }}"
            state: "{{ __start_containers_async_item.state | default('started') }}"
            env: "{{ __start_containers_async_item.env | default(omit) }}"
            generate_systemd: "{{ __start_containers_async_item.generate_systemd | default(omit) }}"
            cmd_args: "{{ __start_containers_async_item.cmd_args | default(omit) }}"
          async: 1000
          poll: 0
          loop: "{{ lab_containers }}"
          loop_control:
            loop_var: __start_containers_async_item
            label: "{{ __start_containers_async_item.name }}"
          register: __start_containers_async
          changed_when: not __start_containers_async.changed

        - name: Start custom containers | Async
          ansible.builtin.async_status:
            jid: "{{ __start_containers_async_result_item.ansible_job_id }}"
          retries: 60
          delay: 1
          loop: "{{ __start_containers_async.results }}"
          loop_control:
            loop_var: __start_containers_async_result_item
            label: "{{ __start_containers_async_result_item.__start_containers_async_item.name }}"
          until: __start_containers_async_result.finished
          register: __start_containers_async_result
          when: __start_containers_async_result_item.ansible_job_id is defined

        - name: Add custom containers to /etc/hosts
          ansible.builtin.lineinfile:
            path: /etc/hosts
            mode: "0644"
            state: present
            line: "{{ __hosts_file_item.ip }} {{ __hosts_file_item.name }}"
          loop: "{{ lab_containers }}"
          loop_control:
            loop_var: __hosts_file_item
            label: "{{ __hosts_file_item.name }}"

        - name: Wait for container services to start
          ansible.builtin.wait_for:
            host: "{{ __containers_start_async_item.name }}"
            port: "{{ __containers_start_async_item.listen_port }}"
            delay: 1
            timeout: 120
          loop: "{{ lab_containers }}"
          loop_control:
            loop_var: __containers_start_async_item
            label: "{{ __containers_start_async_item.name }}"
          async: 1000
          poll: 0
          register: __containers_start_async
          changed_when: not __containers_start_async.changed

        - name: Wait for container services to start | Async
          ansible.builtin.async_status:
            jid: "{{ __containers_start_async_result_item.ansible_job_id }}"
          retries: 90
          delay: 1
          loop: "{{ __containers_start_async.results }}"
          loop_control:
            loop_var: __containers_start_async_result_item
            label: "{{ __containers_start_async_result_item.__containers_start_async_item.name }}"
          until: __containers_start_async_result.finished
          register: __containers_start_async_result
          when: __containers_start_async_result_item.ansible_job_id is defined

        - name: Enable and start gitea container systemd
          ansible.builtin.systemd:
            name: container-gitea
            state: started
            enabled: true
            daemon_reload: true

        - name: Add custom containers to inventory
          ansible.builtin.add_host:
            name: "{{ __add_containers_item.name }}"
            groups: "{{ __add_containers_item.groups | default(omit) }}"
          # args: "{{ __add_containers_item.args | default(omit) }}"
          loop: "{{ lab_containers }}"
          loop_control:
            loop_var: __add_containers_item
            label: "{{ __add_containers_item.name }}"

    - name: Configure Gitea container
      module_defaults:
        ansible.builtin.uri:
          force_basic_auth: true
          url_username: "{{ student_username }}"
          url_password: "{{ student_password }}"
          validate_certs: false
          body_format: json
      when: ('"containers" in groups' and '"gitea" in inventory_hostnames["containers"]')
      tags:
        - gitea
      block:
        - name: Create Gitea repo - {{ gitea_repo_name }}
          ansible.builtin.uri:
            url: "{{ gitea_app_url }}/api/v1/user/repos"
            method: POST
            body:
              name: "{{ gitea_repo_name }}"
              auto_init: false
              private: false
            status_code: [201, 409]
          changed_when: (__create_user.msg is defined and '"OK" in __create_user.msg')

    - name: Configure local repo - {{ student_username }}
      tags:
        - configure-repo
      become_user: "{{ student_username }}"
      block:
        - name: Recreate repo dir - {{ gitea_repo_name }} # noqa risky-file-permissions
          ansible.builtin.file:
            path: "~{{ student_username }}/{{ gitea_repo_name }}"
            state: "{{ item }}"
            owner: "{{ student_username }}"
            group: "{{ student_username }}"
          become_user: root
          loop:
            - absent
            - directory

        # - name: Extract initial repo files
        #   ansible.builtin.unarchive:
        #     src: "/opt/setup-scripts/{{ track_slug }}/files/acme_repo.tar.gz"
        #     dest: "~{{ student_username }}/{{ gitea_repo_name }}"
        #     remote_src: true
        #     owner: "{{ student_username }}"
        #     group: "{{ student_username }}"

        - name: Copy initial repository files - {{ gitea_repo_name }}
          ansible.builtin.copy:
            src: "/opt/setup-scripts/{{ track_slug }}/{{ gitea_repo_name }}/"
            dest: "~{{ student_username }}/{{ gitea_repo_name }}/"
            remote_src: true
            owner: "{{ student_username }}"
            group: "{{ student_username }}"
            directory_mode: "755"
            mode: "0644"

        - name: Fix directory permissions - {{ gitea_repo_name }}
          ansible.builtin.file:
            path: "~{{ student_username }}/{{ gitea_repo_name }}"
            state: directory
            owner: "{{ student_username }}"
            group: "{{ student_username }}"
            mode: "755"

        - name: Initialise track repo - {{ gitea_repo_name }} # noqa command-instead-of-module
          ansible.builtin.command:
            cmd: /usr/bin/git init
            chdir: "~{{ student_username }}/{{ gitea_repo_name }}"
            creates: "~{{ student_username }}/{{ gitea_repo_name }}/.git"

        - name: Add git configurations - {{ gitea_repo_name }}
          ansible.builtin.template:
            src: "gitconfig.j2"
            owner: "{{ student_username }}"
            group: "{{ student_username }}"
            mode: "0644"
            dest: "~{{ student_username }}/{{ gitea_repo_name }}/.git/config"

        - name: Store repo credentials in git-creds file
          ansible.builtin.copy:
            dest: "~{{ student_username }}/.git-creds"
            content: "{{ gitea_protocol }}://{{ student_username | urlencode }}:{{ student_password | urlencode }}@{{ gitea_hostname }}:{{ gitea_http_port }}"
            owner: "{{ student_username }}"
            group: "{{ student_username }}"
            mode: "0644"

        - name: Push initial commit to repo
          ansible.builtin.command:
            cmd: "{{ item }}"
            chdir: "~{{ student_username }}/{{ gitea_repo_name }}"
          register: __output
          changed_when: __output.rc == 0
          loop:
            - "git checkout -b main"
            - "git add ."
            - "git commit -m'Initial commit'"
            - "git push -u origin main --force"

    - name: Configure worker node firewall
      vars:
        firewall:
          - set_default_zone: internal
            state: enabled
            permanent: true
          - service: cockpit
            state: disabled
            permanent: true
            zone: internal
          - port: 27199/tcp
            state: enabled
            permanent: true
            zone: internal
          - port: 8088/tcp
            state: enabled
            permanent: true
            zone: internal
      ansible.builtin.import_role:
        name: fedora.linux_system_roles.firewall

    - name: Include common image cleanup tasks
      ansible.builtin.include_tasks:
        file: "{{ playbook_dir }}/common/10_image_cleanup.yml"

    - name: Build Cockpit install files cache
      ansible.builtin.dnf:
        name: cockpit
        state: present
        download_only: true
    - name: Include common image cleanup tasks
      ansible.builtin.include_tasks:
        file: "{{ playbook_dir }}/common/10_image_cleanup.yml"

    # https://github.com/redhat-cop/controller_configuration
    - name: Create lab controller objects
      ansible.builtin.import_role:
        name: redhat_cop.controller_configuration.dispatch

    # Run cleanup tasks on images
    - name: Include common image cleanup tasks
      ansible.builtin.include_tasks:
        file: "{{ playbook_dir }}/common/10_image_cleanup.yml"

    - name: Remove known_hosts entries for root
      ansible.builtin.known_hosts:
        name: "{{ item.name }}"
        state: absent
      loop: "{{ gcp_instances }}"

    - name: Remove known_hosts entries for {{ admin_username }}
      ansible.builtin.known_hosts:
        name: "{{ item.name }}"
        state: absent
      become: false
      loop: "{{ gcp_instances }}"

# Create GCP images
- name: Create instruqt images
  hosts: localhost
  gather_facts: false
  tags:
    - create-images

  pre_tasks:
    - name: Include variable tasks
      ansible.builtin.include_tasks:
        file: "{{ playbook_dir }}/common/60_check_vars.yml"
        apply:
          tags:
            - always
      tags:
        - always

  tasks:
    - name: Stop gcloud instances
      when: (gcp_instances is defined) and (gcp_instances | length > 0)
      tags:
        - stop-instances
      block:
        - name: Stop gcloud instances
          google.cloud.gcp_compute_instance:
            name: "{{ __instances_stop_async_item.name }}"
            status: TERMINATED
            zone: "{{ gcp_zone }}"
            labels: "{{ __create_instances_job_async_item.labels | default(omit) }}"
            tags: "{{ __create_instances_job_async_item.tags | default(omit) }}"
            <<: *gcp_login
          loop: "{{ gcp_instances }}"
          loop_control:
            loop_var: __instances_stop_async_item
            label: "{{ __instances_stop_async_item.name }}"
          async: 1000
          poll: 0
          register: __instances_stop_async
          changed_when: not __instances_stop_async.changed

        - name: "Async | Stop gcloud instances"
          ansible.builtin.async_status:
            jid: "{{ __instances_stop_async_result_item.ansible_job_id }}"
          retries: 60
          delay: 1
          loop: "{{ __instances_stop_async.results }}"
          loop_control:
            loop_var: __instances_stop_async_result_item
            label: "{{ __instances_stop_async_result_item.__instances_stop_async_item.name }}"
          until: __instances_stop_async_result.finished
          register: __instances_stop_async_result
          when: __instances_stop_async_result_item.ansible_job_id is defined

    - name: Remove current gcloud images
      when: (gcp_instances is defined) and (gcp_instances | length > 0)
      tags:
        - remove-images
      block:
        - name: Remove current gcloud images
          google.cloud.gcp_compute_image:
            name: "{{ __images_remove_async_item.name }}-image"
            state: absent
            <<: *gcp_login
          loop: "{{ gcp_instances }}"
          loop_control:
            loop_var: __images_remove_async_item
            label: "{{ __images_remove_async_item.name }}"
          async: 1000
          poll: 0
          register: __images_remove_async
          changed_when: not __images_remove_async.changed

        - name: "Async | Remove current gcloud images"
          ansible.builtin.async_status:
            jid: "{{ __images_remove_async_result_item.ansible_job_id }}"
          retries: 35
          delay: 5
          loop: "{{ __images_remove_async.results }}"
          loop_control:
            loop_var: __images_remove_async_result_item
            label: "{{ __images_remove_async_result_item.__images_remove_async_item.name }}"
          until: __images_remove_async_result.finished
          register: __images_remove_async_result
          when: __images_remove_async_result_item.ansible_job_id is defined
      rescue:
        - name: Print error message
          ansible.builtin.fail:
            msg: |
              "Rescue - Unable to remove gcloud images."
              "{{ __images_remove_async_result }}"
          notify:
            - remove instances

    - name: Create new Instruqt images
      notify:
        - remove instances
      block:
        - name: Create gcloud images
          google.cloud.gcp_compute_image:
            name: "{{ __images_create_async_item.name }}-image"
            state: present
            source_disk:
              selfLink: "https://www.googleapis.com/compute/v1/projects/{{ gcp_project }}/zones/{{ gcp_zone }}/disks/{{ __images_create_async_item.name }}" # yamllint disable-line rule:line-length
            labels:
              role: "{{ track_slug }}"
            description: "{{ track_slug }} - {{ __images_create_async_item.name }} image."
            <<: *gcp_login
          loop: "{{ gcp_instances }}"
          loop_control:
            loop_var: __images_create_async_item
            label: "{{ __images_create_async_item.name }}"
          async: 1000
          poll: 0
          register: __images_create_async
          changed_when: not __images_create_async.changed

        - name: "Async | Create new Instruqt gcloud images"
          ansible.builtin.async_status:
            jid: "{{ __images_create_async_result_item.ansible_job_id }}"
          retries: 40
          delay: 5
          loop: "{{ __images_create_async.results }}"
          loop_control:
            loop_var: __images_create_async_result_item
            label: "{{ __images_create_async_result_item.__images_create_async_item.name }}"
          until: __images_create_async_result.finished
          register: __images_create_async_result
          when: __images_create_async_result_item.ansible_job_id is defined
      rescue:
        - name: Print error message
          ansible.builtin.fail:
            msg: |
              "Rescue - Unable to remove gcloud images."
              "{{ __images_create_async_result }}"
          notify:
            - remove instances

  handlers:
    - name: Remove GCP instances
      listen: remove instances
      google.cloud.gcp_compute_instance:
        name: "{{ __remove_instances_job_async_item.name }}"
        state: absent
        zone: "{{ gcp_zone }}"
        labels: "{{ __create_instances_job_async_item.labels | default(omit) }}"
        tags: "{{ __create_instances_job_async_item.tags | default(omit) }}"
        <<: *gcp_login
      loop: "{{ gcp_instances }}"
      loop_control:
        loop_var: __remove_instances_job_async_item
        label: "{{ __remove_instances_job_async_item.name }}"
      async: 1000
      poll: 0
      register: __remove_instances_job_async
      changed_when: not __remove_instances_job_async.changed
      when: (gcp_instances is defined) and (gcp_instances | length > 0)

    - name: "Remove GCP instances | Wait for finish the instance deletion"
      listen: remove instances
      ansible.builtin.async_status:
        jid: "{{ __remove_instances_job_async_result_item.ansible_job_id }}"
      retries: 35
      delay: 5
      loop: "{{ __remove_instances_job_async.results }}"
      loop_control:
        loop_var: __remove_instances_job_async_result_item
        label: "{{ __remove_instances_job_async_result_item.__remove_instances_job_async_item.name }}"
      until: __remove_instances_job_async_result.finished
      register: __remove_instances_job_async_result
      when: __remove_instances_job_async_result_item.ansible_job_id is defined
